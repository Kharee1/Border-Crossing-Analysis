# Border-Crossing-Analysis

I started with importing CSV to read the file and math for methods later used. I started by initially skipping the row of column names

I loaded the data into a dictionary with the column names as keys and the column content as the values inside a list. (ex: {'border': ['US-Mex', 'US-Can'], 'date': ['3/1/2019 0:00', '2/1/2019']}). Once the dictionary is set up, I would use the keys and index the list for what I needed.

For the first question, I used a empty list to see if iterating through the values of "Measure" was equal to the specific travel type. I included a tracker list to keep track of the iterating item and the index of it. By doing this, this allowed me to know where I was in the loop, and where I am in the dictionary values. Once the item that I was looking for was found, I would add that to the tracking list to account for multiple instances of the same travel method. This will allow looking back through data set easier and avoid pulling the same location and same values. This helped a lot because this was a problem I faced. My code would only pull the first index of Pedestrian in my dictionary value, eveen though there were 3 other locations of it in the list. After solving the first problem, I decided to keep the tracker list of Pedestrian since that came up the most and the information regarding the multiple instances was used further in my code.

For the second question counting the total of each type, using the information from the previous question, (because pedestrian came up more than once in the data set) keeping the tracker for pedestrians made looking through everything else easier. The indexes of the pedestrian came out to be 2,3,5 and 6. By having those indexes, it allowed me to add the totals for the corresponding months respectively. Since the other travel options only occurred once, it was simply using the index it occurred at. Following your example for the average, I was able to calculate the average per month by the border. When it came to rounding, using the math method ceil() allowed me to round up to avoid all decimals.

For the descending piece when writing content to the CSV file, I simply used "<", ">" operators. Based on what came back true or false would determine how it's ordered in the CSV out file. As for writing to the CSV file, I did a line by line approach with each cell being a variable. By doing this, in case any changes made to the original file, the new file can update.
